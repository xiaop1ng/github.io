<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="cn">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="xiaop1ng">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="xiaop1ng">
<meta property="og:locale" content="cn">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="xiaop1ng">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/"/>





  <title>xiaop1ng</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="cn">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">xiaop1ng</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">追寻水中桥</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Spring 配置文件/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Spring 配置文件/" itemprop="url">Spring 配置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="不同环境的不同配置"><a href="#不同环境的不同配置" class="headerlink" title="不同环境的不同配置"></a>不同环境的不同配置</h1><p>在 <code>resources</code> 下创建 <code>application-{profile}.yml</code> 文件</p>
<ul>
<li>application.yml</li>
<li>application-dev.yml</li>
<li>application-test.yml</li>
<li>application-prod.yml</li>
</ul>
<p>我们在 <code>application-prod.yml</code> 中描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server:</span><br><span class="line">  port: 80</span><br></pre></td></tr></table></figure>
<p>在 <code>application.yml</code> 中描述</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring:</span><br><span class="line">	profiles:</span><br><span class="line">		active: prod</span><br></pre></td></tr></table></figure>
<p>启动工程之后我们的服务监听端口就变成了 <code>80</code> 了</p>
<h1 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h1><h2 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h2><blockquote>
<p>微服务是一种架构，其中的大型、复杂的软件应用程序由一个或多个更小的服务组成。每个微服务仅负责完成一项代表一种小业务能力的任务。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Dubbo-学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Dubbo-学习/" itemprop="url">Dubbo 学习</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Dubbo-是啥？"><a href="#Dubbo-是啥？" class="headerlink" title="Dubbo 是啥？"></a>Dubbo 是啥？</h1><ul>
<li>一款分布式服务框架</li>
<li>高性能和透明化的RPC远程服务调用方案</li>
<li>SOA服务治理方案</li>
</ul>
<p>每天为2千多个服务提供大于30亿次访问量支持，并被广泛应用于阿里巴巴集团的各成员站点以及别的公司的业务中。</p>
<h1 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h1><p><a href="https://juejin.im/post/5a37600b6fb9a0450671b86a" target="_blank" rel="noopener">https://juejin.im/post/5a37600b6fb9a0450671b86a</a></p>
<p><a href="http://dubbo.apache.org/#!/docs/admin/install/provider-demo.md?lang=zh-cn" target="_blank" rel="noopener">http://dubbo.apache.org/#!/docs/admin/install/provider-demo.md?lang=zh-cn</a></p>
<h1 id="Dubbo-注册中心"><a href="#Dubbo-注册中心" class="headerlink" title="Dubbo 注册中心"></a>Dubbo 注册中心</h1><p>对于服务提供方，它需要发布服务，而且由于应用系统的复杂性，服务的数量、类型也不断膨胀；<br>对于服务消费方，它最关心如何获取到它所需要的服务，而面对复杂的应用系统，需要管理大量的服务调用。<br>而且，对于服务提供方和服务消费方来说，他们还有可能兼具这两种角色，即既需要提供服务，有需要消费服务。</p>
<p>通过将服务统一管理起来，可以有效地优化内部应用对服务发布/使用的流程和管理。服务注册中心可以通过特定协议来完成服务对外的统一。</p>
<h1 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h1><h2 id="ZooKeeper-是啥"><a href="#ZooKeeper-是啥" class="headerlink" title="ZooKeeper 是啥"></a>ZooKeeper 是啥</h2><p>ZooKeeper是Apache软件基金会的一个软件项目，他为大型分布式计算提供开源的分布式配置服务、同步服务和命名注册。<br>ZooKeeper曾经是Hadoop的一个子项目，但现在是一个独立的顶级项目。</p>
<h2 id="目录接口"><a href="#目录接口" class="headerlink" title="目录接口"></a>目录接口</h2><ul>
<li>bin<br>可执行脚本</li>
<li>conf<br>配置（生效的配置文件为 <code>zoo.cfg</code>）</li>
<li>lib<br>依赖包</li>
<li>contrib<br>一些用于操作zk的工具包</li>
<li>recipes<br>zk某些用法的代码示例</li>
</ul>
<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Scope-类型"><a href="#Scope-类型" class="headerlink" title="Scope 类型"></a>Scope 类型</h2><ol>
<li>compile：默认值 他表示被依赖项目需要参与当前项目的编译，还有后续的测试，运行周期也参与其中，是一个比较强的依赖。打包的时候通常需要包含进去</li>
<li>test：依赖项目仅仅参与测试相关的工作，包括测试代码的编译和执行，不会被打包，例如：junit</li>
<li>runtime：表示被依赖项目无需参与项目的编译，不过后期的测试和运行周期需要其参与。与compile相比，跳过了编译而已。例如JDBC驱动，适用运行和测试阶段</li>
<li>provided：打包的时候可以不用包进去，别的设施会提供。事实上该依赖理论上可以参与编译，测试，运行等周期。相当于compile，但是打包阶段做了exclude操作</li>
<li>system：从参与度来说，和provided相同，不过被依赖项不会从maven仓库下载，而是从本地文件系统拿。需要添加systemPath的属性来定义路径</li>
</ol>
<h2 id="依赖的传递性"><a href="#依赖的传递性" class="headerlink" title="依赖的传递性"></a>依赖的传递性</h2><p>A依赖B，B依赖C。当前项目为A，只当B在A项目中的scope，那么c在A中的scope是如何得知呢？</p>
<p>当C是test或者provided时，C直接被丢弃，A不依赖C；（排除传递依赖）</p>
<p>否则A依赖C，C的scope继承与B的scope</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Java 中的函数式编程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Java 中的函数式编程/" itemprop="url">Java 中的函数式编程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="函数式编程途径"><a href="#函数式编程途径" class="headerlink" title="函数式编程途径"></a>函数式编程途径</h1><h2 id="Java-新的思维方式"><a href="#Java-新的思维方式" class="headerlink" title="Java 新的思维方式"></a>Java 新的思维方式</h2><p>关于命令式思考、声明式思考、函数式思考</p>
<blockquote>
<p>命令式编程：关注过程，需要定义程序的每一步，告诉他迭代的每个元素，命令式编程提供了完全的控制权<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">	List&lt;String&gt; pickList = Arrays.asList(&quot;Java&quot;, &quot;Python&quot;, &quot;Lua&quot;, &quot;C++&quot;, &quot;PHP&quot;, &quot;JavaScript&quot;);</span><br><span class="line">	pickBestLangue(pickList);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static void pickBestLangue(List&lt;String&gt; pickList) &#123;</span><br><span class="line">	String result = &quot;best langue not found.&quot;;</span><br><span class="line">	for (String item : pickList) &#123;</span><br><span class="line">		if(item.equals(&quot;PHP&quot;)) &#123;</span><br><span class="line">			result = &quot;PHP is the best langue.&quot;; // 嗯，PHP 是世界上最好的语言</span><br><span class="line">			break;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<blockquote>
<p>声明式编程：仍然需要告诉程序需要做什么，但是很多细节留给了底层的函数库。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private static void pickBestLangue(List&lt;String&gt; pickList) &#123;</span><br><span class="line">	String result = &quot;best langue not found.&quot;;</span><br><span class="line">	if(pickList.contains(&quot;PHP&quot;)) &#123;</span><br><span class="line">		result = &quot;PHP is the best langue.&quot;; // 嗯，PHP 是世界上最好的语言</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>函数式编程：使用高阶函数来完成任务，函数式编程在弱语言（如：JavaScript）中很普及使用。拥有更好的表达能力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private static void pickBestLangue(List&lt;String&gt; pickList) &#123;</span><br><span class="line">	String res = pickList.stream()</span><br><span class="line">			.filter(i -&gt; i.equals(&quot;PHP&quot;))</span><br><span class="line">			.findFirst()</span><br><span class="line">			.orElse(&quot;NotFound.&quot;);</span><br><span class="line">	if(res.equals(&quot;PHP&quot;)) &#123;</span><br><span class="line">		System.out.println(&quot;PHP is the best langue.&quot;); // 嗯，PHP 是世界上最好的语言</span><br><span class="line">	&#125;else &#123;</span><br><span class="line">		System.out.println(&quot;best langue not found.&quot;);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<ul>
<li>函数式代码比命令式代码更简洁。可读性更好。</li>
<li>函数式代码不会表现出明显的易变性，而且使用了更少的垃圾变量。</li>
</ul>
<h2 id="Java-中的高阶函数"><a href="#Java-中的高阶函数" class="headerlink" title="Java 中的高阶函数"></a>Java 中的高阶函数</h2><blockquote>
<p>在 Java 中，要将对象传递给方法，在方法内创建对象，并从方法中返回对象。可以对函数执行同样的操作。也就是说，可以将函数传递给方法，在方法内创建函数，并从方法返回函数。<br>在此上下文中，方法 是类的一部分 — 静态或实例 — 但函数对于方法而言是本地函数，不能特意与类或实例关联。可以接收、创建或返回函数的函数或方法被视为高阶函数。</p>
</blockquote>
<h1 id="函数组合与集合管道模式"><a href="#函数组合与集合管道模式" class="headerlink" title="函数组合与集合管道模式"></a>函数组合与集合管道模式</h1><h2 id="关于语句与表达式"><a href="#关于语句与表达式" class="headerlink" title="关于语句与表达式"></a>关于语句与表达式</h2><p>如果在代码库中快速查找 for，您可能会惊奇地发现，您的代码中对 for 循环的使用非常频繁。我将这种情形称为 for重复(hammer)：只要我们需要循环，似乎就会用到 for。<br>在 Java 中，for 和 while 都是语句。语句执行一个操作，但不会生成任何结果。就本质而言，任何执行有用的操作的语句都会导致数据变化。这是语句表达其效果的唯一方式。而表达式则相反：它们可以得出结果而不会导致变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  IntStream.range(1, 4)</span><br><span class="line">    .forEach(i -&gt; System.out.print(i + &quot;...&quot;));</span><br></pre></td></tr></table></figure>
<p>等价于<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">  for(int i = 1; i &lt; 4; i++) &#123;</span><br><span class="line">System.out.print(i + &quot;...&quot;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="关于-Lambda-表达式"><a href="#关于-Lambda-表达式" class="headerlink" title="关于 Lambda 表达式"></a>关于 Lambda 表达式</h2><p>在许多情况下， Lambda 表达式的存在只是为了传递一个或多个形参。<br>在函数式编程中，常常传递 Lambda 表达式作为匿名函数，使用 Lambda 作为更高阶函数的实参。</p>
<p>普通函数（方法）通常有四个元素：</p>
<ul>
<li>一个名称</li>
<li>返回类型</li>
<li>参数列表</li>
<li>主体</li>
</ul>
<p>Lambda 表达式的构成： <code>(parameters) -&gt; body</code> 这里的 <code>-&gt;</code> 将参数列表和函数主体分离。函数的主体可能是一个表达式或一个语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">i -&gt; i*2</span><br></pre></td></tr></table></figure></p>
<p>在上面这个 Lambda 表达式中只有一行。信噪比很高，没有分号，也不需要 return 关键字。这是一个理想的 Lambda 表达式。</p>
<p>当然，有很多时候，我们的函数主体可能需要包含多行表达式或语句。在这种情况下，分号必不可少，也会需要 return 关键字，因为主体包含多行，括号(<code>{}</code>) 也是必须的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i -&gt; &#123;</span><br><span class="line">	int square = i*i;</span><br><span class="line">	int number = square/2 + 1;</span><br><span class="line">	return square + number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="JDK8-中的新的内置函数接口"><a href="#JDK8-中的新的内置函数接口" class="headerlink" title="JDK8 中的新的内置函数接口"></a>JDK8 中的新的内置函数接口</h2><blockquote>
<p>最常用的接口包括 Function&lt;T, R&gt;、Predicate<t> 和 Consumer<t>，它们是在 java.util.function 包中定义的。Stream 的 map 方法接受 Function&lt;T, R&gt; 作为参数。类似地，filter 使用 Predicate<t>，forEach 使用 Consumer<t>。该包还有其他函数接口，比如 Supplier<t>、BiConsumer&lt;T, U&gt; 和 BiFunction&lt;T, U, R&gt;。</t></t></t></t></t></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Spring Cloud 学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Spring Cloud 学习/" itemprop="url">Spring Cloud</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Spring Cloud 为开发人员提供了快速构建分布式系统的一些工具，包括配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等。<br>Spring Cloud 是基于 SpringBoot 的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Java 注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Java 注解/" itemprop="url">Java 中的注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h1><h2 id="糟糕的技术文档或者技术文章"><a href="#糟糕的技术文档或者技术文章" class="headerlink" title="糟糕的技术文档或者技术文章"></a>糟糕的技术文档或者技术文章</h2><p>我们经常在代码中看到 <code>@Override</code>, <code>@Service</code>, <code>@Autowired</code> 等注解，那么究竟这些注解是干吗的，怎么工作的。</p>
<p>使用专业名词来介绍专业名词。</p>
<blockquote>
<p>可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。</p>
</blockquote>
<p>注解用于为 Java 代码提供元数据</p>
<h2 id="注解的定义"><a href="#注解的定义" class="headerlink" title="注解的定义"></a>注解的定义</h2><p>如同 <code>class</code> 和 <code>interface</code> 一样，注解也属于一种类型。</p>
<p>注解通过 <code>@interface</code> 关键字定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public @interface MyAnnotation &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="注解的使用"><a href="#注解的使用" class="headerlink" title="注解的使用"></a>注解的使用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@MyAnnotation</span><br><span class="line">public class Test&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们在 Test 类上面使用了 <code>@MyAnnotation</code> 注解，这个行为可以理解为我们在 Test 类上贴上了 <code>@MyAnnotation</code> 这个标签</p>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解是描述注解的注解，也就是解释标签的标签。</p>
<p>元标签有 <code>@Retention</code>、<code>@Documented</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Repeatable</code> 5 种。</p>
<h2 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h2><p>Retention 的中文意思是“保留，保持”。</p>
<p><code>@Retention</code> 定义被它所注解的注解保留多久，有三种策略（SOURCE, CLASS, RUNTIME）缺省值是 CLASS</p>
<ul>
<li>RetentionPolicy.SOURCE 编译器忽略</li>
<li>RetentionPolicy.CLASS 注解保留在 class 文件中，但是运行时不被 VM 保留。</li>
<li>RetentionPolicy.RUNTIME 保留至运行时。既可以在运行时通过反射去获取注解信息。</li>
</ul>
<h2 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h2><p>这个应该不用解释，它的作用是能够将注解中的元素包含到 Javadoc 中去。</p>
<h2 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h2><p>Target 是目标的意思，<code>@Target</code> 指定了注解应用的地方，当一个注解被 <code>@Target</code> 注解时，这个注解就被限定了使用场景。</p>
<ul>
<li>ElementType.ANNOTATION_TYPE 可以给一个注解进行注解</li>
<li>ElementType.CONSTRUCTOR 可以给构造方法进行注解</li>
<li>ElementType.FIELD 可以给属性进行注解</li>
<li>ElementType.LOCAL_VARIABLE 可以给局部变量进行注解</li>
<li>ElementType.METHOD 可以给方法进行注解</li>
<li>ElementType.PACKAGE 可以给一个包进行注解</li>
<li>ElementType.PARAMETER 可以给一个方法内的参数进行注解</li>
<li>ElementType.TYPE 可以给一个类型进行注解，比如类、接口、枚举</li>
</ul>
<h2 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h2><p>Inherited 是继承的意思，当一个注解 <code>@MyAnnotation</code> 被 <code>@Inherited</code> 注解时，那么一个被 <code>@MyAnnotation</code> 注解的类他的所有子类都继承了该类的 <code>@MyAnnotation</code> 。<br>在我们现实生活中也有类似的例子，比如说： 富二代、富三代、拆二代、官二代这些标签。</p>
<h2 id="Repeatable"><a href="#Repeatable" class="headerlink" title="@Repeatable"></a>@Repeatable</h2><p>Repeatable 是可重复的意思，<code>@Repeatable</code> 是 Java8 加入的，他其实算是一语法糖，看个例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Roles(&#123;@Role(name=&quot;coder&quot;), @Role(name=&quot;artist&quot;), @Role(name=&quot;scientist&quot;)&#125;)</span><br></pre></td></tr></table></figure>
<p>这个注解描述了一个程序员可能同时是一个艺术家，也是一个科学家。</p>
<h2 id="注解的属性"><a href="#注解的属性" class="headerlink" title="注解的属性"></a>注解的属性</h2><p>注解的属性也叫做成员变量。注解只有成员变量，没有方法。注解的成员变量在注解的定义中以“无形参的方法”形式来声明，其方法名定义了该成员变量的名字，其返回值定义了该成员变量的类型, <code>default</code>  关键字定义了属性的缺省值。</p>
<p>我们看一个 Spring 里面常用的注解，一个用于映射请求路由的注解 <code>@RequestMapping</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Mapping</span><br><span class="line">public @interface RequestMapping &#123;</span><br><span class="line">    String name() default &quot;&quot;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;path&quot;)</span><br><span class="line">    String[] value() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    @AliasFor(&quot;value&quot;)</span><br><span class="line">    String[] path() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    RequestMethod[] method() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] params() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] headers() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] consumes() default &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    String[] produces() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到 <code>@RequestMapping</code> 里常用的属性 value, method 等, 我们使用他的方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@RequestMapping(value = &quot;/&quot;, method = RequestMethod.GET)</span><br></pre></td></tr></table></figure>
<h2 id="注解的使用-1"><a href="#注解的使用-1" class="headerlink" title="注解的使用"></a>注解的使用</h2><p>我们知道注解拥有自己的属性，那么我们需要怎么来使用呢？通常情况下我们需要使用反射的方式去取出注解中的属性值。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Netty 学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Netty 学习/" itemprop="url">Netty</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="什么是-Netty"><a href="#什么是-Netty" class="headerlink" title="什么是 Netty"></a>什么是 Netty</h1><p>Netty 是一个利用 Java 的高级网络的能力，隐藏其背后的复杂性而提供一个易于使用的 API 的客户端/服务器框架。<br>Netty 已经实现了的协议就有 FTP, SMTP, HTTP, WebSocket 和 SPDY 以及其他二进制和基于文本的协议。</p>
<p>下面贴出<a href="http://netty.io/index.html" target="_blank" rel="noopener">官网</a>的介绍：</p>
<blockquote>
<p>Netty is an asynchronous event-driven network application framework<br>for rapid development of maintainable high performance protocol servers &amp; clients.</p>
</blockquote>
<p>是的，Netty 是一个异步和事件驱动的网络框架，下面一起来看一下几个核心概念。</p>
<h1 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h1><blockquote>
<p>Channel 是 NIO 基本的结构。它代表了一个用于连接到实体如硬件设备、文件、网络套接字或程序组件,能够执行一个或多个不同的 I/O 操作（例如读或写）的开放连接。<br>现在,把 Channel 想象成一个可以“打开”或“关闭”,“连接”或“断开”和作为传入和传出数据的运输工具。</p>
</blockquote>
<h1 id="Callback"><a href="#Callback" class="headerlink" title="Callback"></a>Callback</h1><blockquote>
<p>callback(回调)通常是一个方法,提供给另一种方法作为引用,这样后者就可以在某个合适的时间调用前者。<br>Netty 内部使用回调处理事件时。一旦这样的回调被触发，事件可以由接口 ChannelHandler 的实现来处理。</p>
</blockquote>
<h1 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h1><blockquote>
<p>Future 提供了另外一种通知应用操作已经完成的方式。这个对象作为一个异步操作结果的占位符,它将在将来的某个时候完成并提供结果。<br>JDK 附带接口 java.util.concurrent.Future ,但所提供的实现只允许您手动检查操作是否完成或阻塞了。这是很麻烦的，所以 Netty 提供自己了的实现,ChannelFuture,用于在执行异步操作时使用。<br>每个 Netty 的 outbound I/O 操作都会返回一个 ChannelFuture;这样就不会阻塞。这就是 Netty 所谓的“自底向上的异步和事件驱动”。</p>
</blockquote>
<h1 id="Event-amp-Handler"><a href="#Event-amp-Handler" class="headerlink" title="Event &amp; Handler"></a>Event &amp; Handler</h1><p>Netty 使用不同的事件来通知我们更改的状态或操作的状态。这使我们能够根据发生的事件触发适当的行为。<br>这些行为可能包括：</p>
<ul>
<li>日志</li>
<li>数据转换</li>
<li>流控制</li>
<li>应用程序逻辑</li>
</ul>
<p>由于 Netty 是一个网络框架,事件很清晰的跟入站或出站数据流相关。因为一些事件可能触发传入的数据或状态的变化包括:</p>
<ul>
<li>活动或非活动连接</li>
<li>数据的读取</li>
<li>用户事件</li>
<li>错误</li>
</ul>
<p>出站事件是由于在未来操作将触发一个动作。这些包括:</p>
<ul>
<li>打开或关闭一个连接到远程</li>
<li>写或冲刷数据到 socket</li>
</ul>
<p>每个事件都可以分配给用户实现处理程序类的方法。这说明了事件驱动的范例可直接转换为应用程序构建块。<br>Netty 的 ChannelHandler 是各种处理程序的基本抽象。想象下，每个处理器实例就是一个回调，用于执行对各种事件的响应。</p>
<h1 id="SELECTOR-EVENT-amp-EVENT-LOOP"><a href="#SELECTOR-EVENT-amp-EVENT-LOOP" class="headerlink" title="SELECTOR, EVENT &amp; EVENT LOOP"></a>SELECTOR, EVENT &amp; EVENT LOOP</h1><p>Netty 通过触发事件从应用程序中抽象出 Selector，从而避免手写调度代码。EventLoop 分配给每个 Channel 来处理所有的事件，包括</p>
<ul>
<li>注册感兴趣的事件</li>
<li>调度事件到 ChannelHandler</li>
<li>安排进一步行动</li>
</ul>
<h1 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h1><p>Netty 应用程序通过设置 bootstrap（引导）类的开始，该类提供了一个 用于应用程序网络层配置的容器。</p>
<h1 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h1><p>ChannelHandler 支持很多协议，并且提供用于数据处理的容器。我们已经知道 ChannelHandler 由特定事件触发。 ChannelHandler 可专用于几乎所有的动作，包括将一个对象转为字节（或相反），执行过程中抛出的异常处理。</p>
<h1 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h1><p>Netty 所有的 I/O 操作都是异步。因为一个操作可能无法立即返回，我们需要有一种方法在以后确定它的结果。出于这个目的，Netty 提供了接口 ChannelFuture,它的 addListener 方法注册了一个 ChannelFutureListener ，当操作完成时，可以被通知（不管成功与否）。</p>
<h1 id="ChannelHandler-和-ChannelPipeline"><a href="#ChannelHandler-和-ChannelPipeline" class="headerlink" title="ChannelHandler 和 ChannelPipeline"></a>ChannelHandler 和 ChannelPipeline</h1><p><code>ChannelPipeline</code> 是 <code>ChannelHandler</code> 链的容器。<br>在很多方面的 ChannelHandler 是引用程序的核心，在 Netty 中有两个方向的数据流： </p>
<ul>
<li>入站（<code>ChannelInboundHandler</code>）：数据是从用户应用程序到远程主机</li>
<li>出站（<code>ChannelOutboundHandler</code>）：数据时从远程主机到用户应用程序</li>
</ul>
<p>这里的 <code>ChannelInboundHandler</code> 接口和 <code>ChannelOutboundHandler</code> 接口均集成自 <code>ChannelHandler</code> 接口。</p>
<h1 id="使用-Netty-创建一个-HTTP-服务器"><a href="#使用-Netty-创建一个-HTTP-服务器" class="headerlink" title="使用 Netty 创建一个 HTTP 服务器"></a>使用 Netty 创建一个 HTTP 服务器</h1><p>步骤：</p>
<ol>
<li>一个服务端的 Handler：用于处理连接创建后和接收到信息后的业务，构建一个 FullHttpResponse 对象输出。</li>
<li>Server：配置服务器的启动代码</li>
</ol>
<h1 id="SPDY"><a href="#SPDY" class="headerlink" title="SPDY"></a>SPDY</h1><blockquote>
<p>SPDY(读作“speedy”)是一个谷歌开发的开放的网络协议，主要运用于 web 内容传输。SPDY 操纵 HTTP 流量,目标是减少 web 页面加载延迟,提高网络安全。SPDY 达到通过压缩、多路复用和优先级来减少延迟，虽然这取决于网络和网站部署条件的组合。“SPDY”这个名字是谷歌的一个商标,不是一个首字母缩写。（摘自<a href="http://en.wikipedia.org/wiki/SPDY）" target="_blank" rel="noopener">http://en.wikipedia.org/wiki/SPDY）</a></p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Spring Core/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Spring Core/" itemprop="url">Spring Core</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h1><p>依赖注入这个词让人望而生畏，现在已经演变成一项复杂的编程技巧或设计模式理念。但事实证明，依赖注入并不像它听上去那么复杂。在项目中应用DI，你会发现你的代码会变得异常简单并且更容易理解和测试。</p>
<h2 id="DI-是如何实现的"><a href="#DI-是如何实现的" class="headerlink" title="DI 是如何实现的"></a>DI 是如何实现的</h2><h4 id="关于耦合性"><a href="#关于耦合性" class="headerlink" title="关于耦合性"></a>关于耦合性</h4><p>耦合具有两面性（two-headed beast）。一方面，紧密耦合的代码难以测试、难以复用、难以理解，并且典型地表现出“打地鼠”式的bug特性（修复一个bug，将会出现一个或者更多新的bug）。另一方面，一定程度的耦合又是必须的——完全没有耦合的代码什么也做不了。为了完成有实际意义的功能，不同的类必须以适当的方式进行交互。总而言之，耦合是必须的，但应当被小心谨慎地管理。</p>
<h4 id="DI-益处"><a href="#DI-益处" class="headerlink" title="DI 益处"></a>DI 益处</h4><p>DI 带来最大的益处是松耦合</p>
<h4 id="Spring-容器（container）"><a href="#Spring-容器（container）" class="headerlink" title="Spring 容器（container）"></a>Spring 容器（container）</h4><p>Spring 容器负责创建对象，装配它们，配置它们并管理它们的整个生命周期，从生存到死亡（在这里，可能就是 new 到 finalize()）。</p>
<p>Spring 容器并不是只有一个。Spring 自带了多个容器实现，可以归为两种不同的类型。bean 工厂（由org.springframework.beans.factory.BeanFactory接口定义）是最简单的容器，提供基本的 DI 支持。应用上下文（由org.springframework.context.ApplicationContext接口定义）基于 BeanFactory 构建，并提供应用框架级别的服务，例如从属性文件解析文本信息以及发布应用事件给感兴趣的事件监听者。</p>
<h4 id="应用上下文（ApplicationContext）"><a href="#应用上下文（ApplicationContext）" class="headerlink" title="应用上下文（ApplicationContext）"></a>应用上下文（ApplicationContext）</h4><ul>
<li>AnnotationConfigApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring 应用上下文。</li>
<li>AnnotationConfigWebApplicationContext：从一个或多个基于 Java 的配置类中加载 Spring Web 应用上下文。</li>
<li>ClassPathXmlApplicationContext：从类路径下的一个或多个 XML 配置文件中加载上下文定义，把应用上下文的定义文件作为类资源。</li>
<li>FileSystemXmlapplicationcontext：从文件系统下的一个或多个 XML 配置文件中加载上下文定义。</li>
<li>XmlWebApplicationContext：从 Web 应用下的一个或多个 XML 配置文件中加载上下文定义。</li>
</ul>
<p>有了这些上下文之后，我们可以调用上下文的 getBean() 方法从 Spring 容器中获取 bean。</p>
<p>在 Spring 中 bean 的生命周期：</p>
<p><img src="img/1533713094299.png" alt="1533713094299"></p>
<p>详细的过程如下：</p>
<p>1．Spring对bean进行实例化；</p>
<p>2．Spring将值和bean的引用注入到bean对应的属性中；</p>
<p>3．如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法；</p>
<p>4．如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入；</p>
<p>5．如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来；</p>
<p>6．如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessBeforeInitialization()方法；</p>
<p>7．如果bean实现了InitializingBean接口，Spring将调用它们的after-PropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用；</p>
<p>8．如果bean实现了BeanPostProcessor接口，Spring将调用它们的post-ProcessAfterInitialization()方法；</p>
<p>9．此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁；</p>
<p>10．如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。</p>
<h4 id="装配-Bean"><a href="#装配-Bean" class="headerlink" title="装配 Bean"></a>装配 Bean</h4><p>创建对象之间的协作关系的行为通常称为装配（wiring）,这也是依赖注入（DI）的本质。</p>
<p>Spring 从两个角度实现自动化装配：</p>
<ul>
<li>组件扫描（component scanning）：Spring 会自动发现应用上下文中所创建的 bean。</li>
<li>自动装配（autowiring）：Spring 自动满足 bean 之间的依赖</li>
</ul>
<h4 id="条件化的-Bean"><a href="#条件化的-Bean" class="headerlink" title="条件化的 Bean"></a>条件化的 Bean</h4><p>我们的 Bean 可能只想在某些特定的环境下被创建，比如说我们只想在生产环境下创建一个特殊的 Bean。 </p>
<p>在 Spring 4 之后引入了 <code>@Conditional</code> 注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@Conditional</span>(ProdExistsCondition.class)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ProdBean <span class="title">prodBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ProdBean();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置给 <code>@Conditional</code> 的类可以是任意实现了 <code>Condition</code> 接口的类型。可以看出来，这个接口实现起来很简单直接，只需提供 matches() 方法的实现即可。如果 matches() 方法返回 true，那么就会创建带有 <code>@Conditional</code> 注解的 bean。如果 matches() 方法返回 false，将不会创建这些 bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProdExistsCondition</span> <span class="keyword">implements</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(ConditionContext ctx, AnnotatedTypeMetadata metadata)</span> </span>&#123;</span><br><span class="line">        Environment env = ctx.getEnvironment();</span><br><span class="line">        <span class="keyword">return</span> env.containsProperty(<span class="string">"prod"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="优先选择的-Bean"><a href="#优先选择的-Bean" class="headerlink" title="优先选择的 Bean"></a>优先选择的 Bean</h4><p>我们都知道面向接口编程，就像我们 MVC 三层结构中 Controller 中注入一个 Service， 而这个 Service 的接口存在多个实现类时，Spring 会报 <code>NoUniqueBeanDefinitionException</code> 异常。因为 Spring 无法自主的去选择一个合适的实现类。这时我们需要给 Spring 提供帮助，让他能够找到合适的首选（primary）的 Bean。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IceCream</span> <span class="keyword">implements</span> <span class="title">Dessert</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><p>在默认情况下，Spring 应用上下文中所有 bean 都是作为以单例（singleton）的形式创建的。也就是说，不管给定的一个 bean 被注入到其他 bean 多少次，每次所注入的都是同一个实例。</p>
<p>Spring 定义了多种作用域，缺省值是 Singleton。</p>
<ul>
<li>单例（Singleton）：在整个应用中，只创建bean的一个实例。</li>
<li>原型（Prototype）：每次注入或者通过Spring应用上下文获取的时候，都会创建一个新的bean实例。</li>
<li>会话（Session）：在Web应用中，为每个会话创建一个bean实例。</li>
<li>请求（Rquest）：在Web应用中，为每个请求创建一个bean实例。</li>
</ul>
<p>我们知道了 Spring 容器中的 Bean 默认是单例的，但是对于易变的类型而言，这并不合适，我们需要使用使用<code>@Scope</code> 注解来配置，它可以与 <code>@Component</code> 或 <code>@Bean</code> 一起使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope</span>(ConfigurableBeanFactory.SCOPE_PROTOTYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notepad</span> </span>&#123; ... &#125;</span><br></pre></td></tr></table></figure>
<h4 id="Spring-表达式"><a href="#Spring-表达式" class="headerlink" title="Spring 表达式"></a>Spring 表达式</h4><p>Spring Expression Language，SpEL</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value</span>(<span class="string">"#&#123;T(System).currentTimeMillis()&#125;"</span>)</span><br></pre></td></tr></table></figure>
<h1 id="JPA"><a href="#JPA" class="headerlink" title="JPA"></a>JPA</h1><p>Spring Data能够让我们只编写Repository接口就可以了。根本就不再需要实现类了。</p>
<p>我们需要将我们的 Repository（DAO 层） 扩展 Spring Data JPA 的 <code>JpaRepository</code> 接口</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDao</span></span></span><br><span class="line"><span class="class">       <span class="keyword">extends</span> <span class="title">JpaRepository</span>&lt;<span class="title">User</span>, <span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function">User <span class="title">findByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findByUsername() 方法非常简单，但是 Spring Data 也能处理更加有意思的方法名称。Repository 方法是由一个动词、一个可选的主题（Subject）、关键词By以及一个断言所组成。在 findByUsername() 这个样例中，动词是find，断言是 Username，主题并没有指定，暗含的主题是 User。</p>
<p>作为编写 Repository 方法名称的样例，我们参照名为 readUserByUsernameOrDisplayname() 的方法，看一下方法中的各个部分是如何映射的。图11.1展现了这个方法是如何拆分的。</p>
<p>我们可以看到，这里的动词是 read，与之前样例中的find有所差别。Spring Data 允许在方法名中使用四种动词：get、read、find 和 count。其中，动词 get、read 和 find 是同义的，这三个动词对应的 Repository 方法都会查询数据并返回对象。而动词 count 则会返回匹配对象的数量，而不是对象本身。</p>
<p><img src="img/1533723146175.png" alt="1533723146175"></p>
<p>在断言中，会有一个或多个限制结果的条件。每个条件必须引用一个属性，并且还可以指定一种比较操作。如果省略比较操作符的话，那么这暗指是一种相等比较操作。不过，我们也可以选择其他的比较操作，包括如下的种类：</p>
<ul>
<li>IsAfter、After、IsGreaterThan、GreaterThan</li>
<li>IsGreaterThanEqual、GreaterThanEqual</li>
<li>IsBefore、Before、IsLessThan、LessThan</li>
<li>IsLessThanEqual、LessThanEqual</li>
<li>IsBetween、Between</li>
<li>IsNull、Null</li>
<li>IsNotNull、NotNull</li>
<li>IsIn、In</li>
<li>IsNotIn、NotIn</li>
<li>IsStartingWith、StartingWith、StartsWith</li>
<li>IsEndingWith、EndingWith、EndsWith</li>
<li>IsContaining、Containing、Contains</li>
<li>IsLike、Like</li>
<li>IsNotLike、NotLike</li>
<li>IsTrue、True</li>
<li>IsFalse、False</li>
<li>Is、Equals</li>
<li>IsNot、Not</li>
</ul>
<p>看到这么多的断言贯彻了约定大于配置的思想，这里列出来的断言也只是一部分。</p>
<p>如果所需的数据无法通过方法名称进行恰当地描述，那么我们可以使用@Query注解，为Spring Data提供要执行的查询。对于findAllGmailSpitters()方法，我们可以按照如下的方式来使用@Query注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Query</span>(<span class="string">"select s from Spitter s where s.email like '%gmail.com'"</span>)</span><br><span class="line"><span class="function">List&lt;Spitter&gt; <span class="title">findAllGmailSpitters</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>
<h1 id="REST"><a href="#REST" class="headerlink" title="REST"></a>REST</h1><p>为了理解REST是什么，我们将它的首字母缩写拆分为不同的构成部分：</p>
<ul>
<li>表述性（Representational）：REST资源实际上可以用各种形式来进行表述，包括XML、JSON（JavaScript Object Notation）甚至HTML——最适合资源使用者的任意形式；</li>
<li>状态（State）：当使用REST的时候，我们更关注资源的状态而不是对资源采取的行为；</li>
<li>转移（Transfer）：REST涉及到转移资源数据，它以某种表述性形式从一个应用转移到另一个应用。</li>
</ul>
<p>在REST中，资源通过URL进行识别和定位。至于RESTful URL的结构并没有严格的规则，但是URL应该能够识别资源，而不是简单的发一条命令到服务器上。再次强调，关注的核心是事物，而不是行为。</p>
<p>REST中会有行为，它们是通过HTTP方法来定义的。具体来讲，也就是GET、POST、PUT、DELETE、PATCH以及其他的HTTP方法构成了REST中的动作。这些HTTP方法通常会匹配为如下的CRUD动作：</p>
<ul>
<li>Create：POST</li>
<li>Read：GET</li>
<li>Update：PUT或PATCH</li>
<li>Delete：DELETE</li>
</ul>
<h1 id="Spring-Email"><a href="#Spring-Email" class="headerlink" title="Spring Email"></a>Spring Email</h1><p>Spring Email 抽象的核心是 <code>MailSender</code> 接口</p>
<p>SpringBoot 中需要添加 spring-boot-starter-mail 这个 <code>starter</code></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-mail<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接着配置邮件相关的账户密码</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># email</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">    mail:</span></span><br><span class="line"><span class="attr">      host:</span> <span class="string">smtp.163.com</span></span><br><span class="line"><span class="attr">      username:</span> <span class="number">13227379709</span><span class="string">@163.com</span></span><br><span class="line"><span class="attr">      password:</span> <span class="string">abcd1234</span></span><br><span class="line"><span class="attr">      properties:</span></span><br><span class="line"><span class="attr">        mail:</span></span><br><span class="line"><span class="attr">          smtp:</span></span><br><span class="line"><span class="attr">            auth:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">          starttls:</span></span><br><span class="line"><span class="attr">            enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">            required:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>使用 <code>JavaMailSender</code>（<code>JavaMailSender</code> 继承自 <code>MailSender</code> 接口） 发送一封邮件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">   <span class="keyword">private</span> JavaMailSender sender;</span><br><span class="line">   </span><br><span class="line">   <span class="meta">@GetMapping</span>(<span class="string">"/send"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">sendMail</span><span class="params">()</span></span>&#123;</span><br><span class="line">       SimpleMailMessage message = <span class="keyword">new</span> SimpleMailMessage();</span><br><span class="line">       message.setFrom(<span class="string">"13227379709@163.com"</span>);</span><br><span class="line">       message.setTo(<span class="string">"784516419@qq.com"</span>);</span><br><span class="line">       message.setSubject(<span class="string">"主题"</span>);</span><br><span class="line">       message.setText(<span class="string">"这是内容"</span>);</span><br><span class="line">       sender.send(message);</span><br><span class="line">       <span class="keyword">return</span> <span class="string">"ok"</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Hibernate/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Hibernate/" itemprop="url">Hibernate</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p><img src="img/hibernate架构.png" alt="hibernate"></p>
<p>Hibernate实现了 JPA (Java Persistence API) 规范，JPA 接口和 Hibernate 特定实现之间的关联可以在下图中可视化： </p>
<p><img src="img/hibernate_02.png" alt="Hibernate"></p>
<h4 id="Hibernate-将类型分为两种"><a href="#Hibernate-将类型分为两种" class="headerlink" title="Hibernate 将类型分为两种"></a>Hibernate 将类型分为两种</h4><ul>
<li>value type</li>
<li>entity type</li>
</ul>
<p>value type 在 <code>Hibernate</code> 中有三种子类别</p>
<ul>
<li>基本类型<ul>
<li>可以由 <code>Hibernate</code> 在 Java Bean 与 DB 之间转换的数据类型</li>
</ul>
</li>
<li>可嵌入的类型由 <code>@Embeddable</code> 注解的对象作为 Java Bean 的属性</li>
<li>集合类型</li>
</ul>
<h4 id="实体映射"><a href="#实体映射" class="headerlink" title="实体映射"></a>实体映射</h4><p>可以有用户显式制定（使用 <code>@Table</code> 或 <code>@Column</code>）, 也可以由 Hibernate 通过 <a href="http://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html#ImplicitNamingStrategy" target="_blank" rel="noopener">ImplicitNamingStrategy</a> 契约隐式确定 。 </p>
<p>其中 JPA 定义的隐式命名规则务必坚持使用 <code>ImplicitNamingStrategyJpaCompliantImpl</code>（默认值） </p>
<h4 id="Basic"><a href="#Basic" class="headerlink" title="@Basic"></a>@Basic</h4><p>javax.persistence.Basic , 通常 <code>@Basic</code> 可以省略，<code>@Basic</code> 将实体的成员标记为 Hibernate 的基础类型</p>
<p>JPA 规范严格的限制了可以被标记为 <code>@Basic</code> 的 Java 类型：</p>
<ul>
<li>Java基本类型（<code>boolean</code>，<code>int</code>，等） </li>
<li>包装的原始类型（<code>java.lang.Boolean</code>，<code>java.lang.Integer</code> 等） </li>
<li>java.lang.String </li>
<li>java.math.BigInteger </li>
<li>java.math.BigDecimal </li>
<li>java.util.Date </li>
<li>java.util.Calendar </li>
<li>java.sql.Date </li>
<li>java.sql.Time </li>
<li>java.sql.Timestamp </li>
<li><code>byte[]</code> 要么 <code>Byte[]</code> </li>
<li><code>char[]</code> 要么 <code>Character[]</code> </li>
<li>enums </li>
<li>实现的任何其他类型 <code>Serializable</code> （JPA对 <code>Serializable</code> 类型的“支持” 是直接将其状态序列化到数据库）。 </li>
</ul>
<h4 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Formula</span>(<span class="string">"lastLoginTime - createTime"</span>)</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> joinTime;</span><br></pre></td></tr></table></figure>
<h4 id="CreationTimestamp-与-UpdateTimestamp"><a href="#CreationTimestamp-与-UpdateTimestamp" class="headerlink" title="@CreationTimestamp 与 @UpdateTimestamp"></a>@CreationTimestamp 与 @UpdateTimestamp</h4><p>创建时间和更新时间自动维护</p>
<h4 id="官方指南"><a href="#官方指南" class="headerlink" title="官方指南"></a>官方指南</h4><p><a href="http://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html" target="_blank" rel="noopener">http://docs.jboss.org/hibernate/orm/5.3/userguide/html_single/Hibernate_User_Guide.html</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/SpringBoot CLI/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/SpringBoot CLI/" itemprop="url">SpringBoot CLI</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="SpringBoot-CLI"><a href="#SpringBoot-CLI" class="headerlink" title="SpringBoot CLI"></a>SpringBoot CLI</h1><p>Cli （Command Line Interface）， 一个可以帮助我们快速构建 SpringBoot 应用的命令行工具。</p>
<h1 id="Quik-Start"><a href="#Quik-Start" class="headerlink" title="Quik Start"></a>Quik Start</h1><p>首先需要下载  <a href="http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/" target="_blank" rel="noopener">http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/</a></p>
<p>我们这里选择的是 2.0.1.RELEASE 版本<br><a href="http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.0.1.RELEASE/spring-boot-cli-2.0.1.RELEASE-bin.zip" target="_blank" rel="noopener">http://repo.spring.io/release/org/springframework/boot/spring-boot-cli/2.0.1.RELEASE/spring-boot-cli-2.0.1.RELEASE-bin.zip</a></p>
<p>下载完成后解压，然后将解压出来的 <code>/bin</code> 目录添加至环境变量中<br>在 <code>cmd</code> 程序中输入 <code>spring --version</code> 会输出</p>
<blockquote>
<p>Spring CLI v2.0.1.RELEASE</p>
</blockquote>
<p>即表明安装配置成功<br>然后我们写一段 Java 程序测试一下</p>
<ul>
<li>Hello.java<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class Hello &#123;</span><br><span class="line">    @RequestMapping(&quot;/hello&quot;)</span><br><span class="line">    public String hello() &#123;</span><br><span class="line">        return &quot;Hello, Cli&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>将 <code>cmd</code> 程序切换至 <code>Hello.java</code> 文件所在目录下执行 <code>spring run Hello.java</code><br>SpringBoot CLI 在这时会构建并启动程序，启动完成后，访问 <a href="http://127.0.0.1:8080/hello" target="_blank" rel="noopener">http://127.0.0.1:8080/hello</a></p>
<blockquote>
<p>Hello, Cli</p>
</blockquote>
<p>到这里我们的测试就已经通过了</p>
<h1 id="SpringBoot-actuator"><a href="#SpringBoot-actuator" class="headerlink" title="SpringBoot actuator"></a>SpringBoot actuator</h1><p>SpringBoot actuator 是一个对应用运行状态监视的工具，actuator 为我们提供了很多可以被监视的端点（Endpoints），同时也支持我们自定端点（Endpoint）。</p>
<h1 id="先启动-actuator"><a href="#先启动-actuator" class="headerlink" title="先启动 actuator"></a>先启动 actuator</h1><p>首先在我们的 SpringBoot 应用中添加上 <code>actuator</code> 的依赖</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>相关配置：</p>
<ul>
<li>application.yml</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># info 配置项（/actuator/info）</span><br><span class="line">info:</span><br><span class="line">  author: xiaop1ng</span><br><span class="line">  email: jianchaoping@gmail.com</span><br><span class="line">  version: 1.0.0</span><br><span class="line"></span><br><span class="line"># 配置 actuator 加载所有的端点</span><br><span class="line">management:</span><br><span class="line">  endpoints:</span><br><span class="line">    web:</span><br><span class="line">      exposure:</span><br><span class="line">        include: &apos;*&apos;</span><br><span class="line">  endpoint:</span><br><span class="line">    health:</span><br><span class="line">      show-details: always</span><br></pre></td></tr></table></figure>
<p>启动 SpringBoot 应用程序后访问路由 <code>/actuator/info</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// http://127.0.0.1:3000/actuator/info</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;author&quot;: &quot;xiaop1ng&quot;,</span><br><span class="line">  &quot;email&quot;: &quot;jianchaoping@gmail.com&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后接着我们可以试一试其他的端点监控的路由</p>
<ul>
<li><code>/actuator/autoconfig</code> 应用的自动化配置报告</li>
<li><code>/actuator/beans</code>  应用上下文创建的所有 Bean</li>
<li><code>/actuator/configprops</code> 应用中配置的属性信息报告</li>
<li><code>/actuator/env</code> 环境属性报告</li>
<li><code>/actuator/mappings</code> SpringMVC 的控制器映射关系报告</li>
<li><code>/actuator/info</code> 自定义的配置信息</li>
<li><code>/actuator/metrics</code> 当前应用的各类重要度量指标</li>
<li><code>/actuator/health</code> 应用的各类健康指标信息</li>
<li><code>/actuator/threaddump</code> 用来暴露程序运行中的线程信息</li>
<li><code>/actuator/httptrace</code> 显示HTTP跟踪信息（默认显示最后100个HTTP请求）</li>
<li><code>/actuator/scheduledtasks</code> 计划任务</li>
</ul>
<p>…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/08/12/Steams API/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xiaop1ng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="xiaop1ng">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/08/12/Steams API/" itemprop="url">Streams API</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-08-12T18:52:39+08:00">
                2018-08-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Java-8-中的-Streams-API"><a href="#Java-8-中的-Streams-API" class="headerlink" title="Java 8 中的 Streams API"></a>Java 8 中的 Streams API</h1><h1 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h1><p>在 Java 8 中加入很多新的 API，其中关于集合和数组增强功能的 API 可以说是备受好评。Streams API 很大程度上方便了 Java 开发过程中对于数据的操作和计算了。我们写一个简单的栗子对比一下在使用到 Streams API 时的便利</p>
<blockquote>
<p>求数组 [7, 8, 4, 5, 1, 6, 4, 1, 9] 中所有的奇数的和</p>
</blockquote>
<p>Java 7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int [] array = &#123;7, 8, 4, 5, 1, 6, 4, 1, 9&#125;;</span><br><span class="line">int sum1 = 0;</span><br><span class="line">for (int i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">	if(array[i]%2 != 0) &#123;</span><br><span class="line">		sum1 += array[i];</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(sum1); // 23</span><br></pre></td></tr></table></figure></p>
<p>Java 8 use Streams API<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">int [] array = &#123;7, 8, 4, 5, 1, 6, 4, 1, 9&#125;;</span><br><span class="line">int sum2 = Arrays.stream(array).filter(i -&gt; i%2 != 0).sum();</span><br><span class="line">System.out.println(sum2); // 23</span><br></pre></td></tr></table></figure></p>
<p>可以看的出来，当使用到 Streams API 结合 Lambda 表达式来操作集合或者数组的时候，代码变得很简洁，可读性也大大的提升了。</p>
<h1 id="Streams-是啥呢"><a href="#Streams-是啥呢" class="headerlink" title="Streams 是啥呢"></a>Streams 是啥呢</h1><p>关于 <code>java.util.stream.Stream</code> 首先需要说明的是 Stream 不是集合，不保存数据，他是关于算法（计算）的，可以进行 <code>map</code>、<code>filter</code> 等操作（熟悉 JavaScript 的同学应该非常习惯对数组使用这些操作）。<code>Stream</code> 就如同一个迭代器，而和迭代器又不同的是，Stream 可以并行化操作。 <code>Stream</code> 的另一特点是，数据源本身可以是无限的。</p>
<blockquote>
<p>我们使用一个 <code>Streams</code> 的时候，通常是三个基本步骤 1.获取数据源 -&gt; 2.数据转换 -&gt; 3.执行操作获取想要的结果</p>
</blockquote>
<h2 id="如何获取一个-Streams"><a href="#如何获取一个-Streams" class="headerlink" title="如何获取一个 Streams"></a>如何获取一个 Streams</h2><p>常用的获取一个 <code>Streams</code> 的方法有：</p>
<ul>
<li><p>数组或集合</p>
<blockquote>
<p>Collection.stream() // 单管<br>Collection.parallelStream() // 多管<br>Arrays.stream(T array) or Stream.of()</p>
</blockquote>
</li>
<li><p>静态工厂</p>
<blockquote>
<p>java.util.stream.IntStream.range()<br>java.nio.file.Files.walk()</p>
</blockquote>
</li>
</ul>
<h2 id="如何去使用一个-Streams"><a href="#如何去使用一个-Streams" class="headerlink" title="如何去使用一个 Streams"></a>如何去使用一个 Streams</h2><p>流的操作类型分为两种：</p>
<blockquote>
<p>Intermediate：一个流可以后面跟随零个或多个 intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用。这类操作都是惰性化的（lazy），就是说，仅仅调用到这类方法，并没有真正开始流的遍历。<br>map (mapToInt, flatMap 等)、 filter、 distinct、 sorted、 peek、 limit、 skip、 parallel、 sequential、 unordered<br>Terminal：一个流只能有一个 terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。Terminal 操作的执行，才会真正开始流的遍历，并且会生成一个结果，或者一个 side effect。<br>forEach、 forEachOrdered、 toArray、 reduce、 collect、 min、 max、 count、 anyMatch、 allMatch、 noneMatch、 findFirst、 findAny、 iterator</p>
</blockquote>
<p>转换大写的一个应用，<code>map</code> 操作通常也被应用在对象转换上比如在 web 开发中将数据库中查询到的数据转换为 api 中适用的对象<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stringList = new ArrayList&lt;&gt;();</span><br><span class="line">stringList.add(&quot;ni&quot;);</span><br><span class="line">stringList.add(&quot;Zhen&quot;);</span><br><span class="line">stringList.add(&quot;mEi&quot;);</span><br><span class="line">List&lt;String&gt; upperCaseStringList = stringList.stream().map(String::toUpperCase).collect(Collectors.toList());</span><br><span class="line">for (String word : upperCaseStringList) &#123;</span><br><span class="line">	System.out.println(word); // NI ZHEN MEI</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">xiaop1ng</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">14</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xiaop1ng</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
